import CPerlCore
import Foundation

struct PerlError: Error, CustomStringConvertible {
  var errorDescription: String
  var description: String { errorDescription }
}

/// A Perl execution environment.
///
/// You create and use Perl interpreters to evaluate Perl scripts from Swift code, to access values that Perl defines or calculates, and to make native objects accessible to Perl.
@available(macOS 10.10, *)
public class PerlInterpreter {
  /// The shared Perl interpreter.
  public static let shared = PerlInterpreter()
  
  /// Preamble to evaluate before all scripts.
  public var preamble = "use v5.30; no strict; "

  var _perl: UnsafeMutableRawPointer!
  
  /// Initializes a new Perl interpreter.
  /// - returns: A new Perl interpreter.
  init() { Self.initialize(); _perl = perlcore_init() }
  
  deinit { perlcore_deinit() }
  
  /// Initializes the Perl environment.
  public class func initialize() { perlcore_sys_init() }
  
  /// Deinitializes the Perl environment.
  public class func deinitialize() { perlcore_sys_term() }
  
  /// Executes the specified Perl code.
  /// - parameters:
  ///   - script: The Perl source code to evaluate.
  /// - returns: The last value generated by the script. Note that a script can result in an undefined Perl value.
  ///
  /// Evaluating a script runs any top-level code.
  @discardableResult
  public func evaluateScript(_ script: String) -> PerlScalarValue {
    (preamble + script).withCString { PerlScalarValue(perlcore_eval_pv($0, 0)) }
  }
  
  /// Whether the latest evaluation succeeded.
  public var evaluationSucceeded: Bool { perlcore_err() == 0 }
  
  /// A Perl exception thrown in evaluation of the script.
  ///
  /// PerlCore assigns any uncaught exception to this property, so you can check this propertyâ€™s value to find uncaught exceptions arising from Perl function calls.
  public var exception: String { String(validatingUTF8: perlcore_errstr())! }
  
  /// Accesses the specified scalar value.
  public subscript(_ name: String, add: Bool = true) -> PerlScalarValue? {
    name.withCString { perlcore_get_sv($0, add ? 1 : 0) }.map { .init($0) }
  }
  
  /// Accesses the specified array value.
  public subscript(array name: String, _ add: Bool = true) -> PerlArrayValue? {
    name.withCString { perlcore_get_av($0, add ? 1 : 0) }.map { .init($0) }
  }
  
  /// Accesses the specified hash value.
  public subscript(hash name: String, _ add: Bool = true) -> PerlHashValue? {
    name.withCString { perlcore_get_hv($0, add ? 1 : 0) }.map { .init($0) }
  }
  
  /// Imports semantics from the specified Perl module.
  ///
  /// This imports some semantics into the current Perl package from the named Perl module, generally by aliasing certain subroutine or variable names into your Perl package.
  @discardableResult
  public func use(_ name: String) throws -> PerlScalarValue {
    let value = evaluateScript("use \(name);")
    if !evaluationSucceeded { throw PerlError(errorDescription: exception) }
    return value
  }
  
  /// Imports semantics from the specified Perl module.
  @discardableResult
  public func use<T>(_ name: String, _ args: T...) throws -> PerlScalarValue {
    try use(name + " " + args.map{ "'\($0)'" }.joined(separator: ","))
  }
}
